"""
Professional LaTeX formatter for research analysis reports.
Generates publication-ready LaTeX documents with ArXiv styling.
"""
import re
from datetime import datetime
from typing import List, Dict, Optional, Tuple
from pathlib import Path


class LaTeXFormatter:
    """
    Professional LaTeX document generator for research reports.

    Features:
    - ArXiv-style document formatting
    - BibTeX bibliography integration
    - Professional tables with booktabs
    - Mathematical equations support
    - Algorithm pseudocode blocks
    - Hyperlinked citations and references
    """

    def __init__(self):
        """Initialize formatter with LaTeX settings."""
        self.document_class = "article"
        self.font_size = "11pt"
        self.column_mode = "twocolumn"

    def generate_document(
        self,
        content: str,
        query: str,
        metadata: Optional[Dict] = None,
        referenced_papers: Optional[List[Dict]] = None,
        bib_basename: str = "references"
    ) -> Tuple[str, str]:
        """
        Generate complete LaTeX document and BibTeX file.

        Args:
            content: Markdown-formatted content
            query: Research query
            metadata: Analysis metadata (usage, models, etc.)
            referenced_papers: List of ArXiv papers to cite
            bib_basename: Base name for bibliography file (without .bib extension)

        Returns:
            Tuple of (latex_content, bibtex_content)
        """
        # Generate BibTeX from papers
        bibtex_content = self._generate_bibtex(referenced_papers) if referenced_papers else ""

        # Build LaTeX document
        latex_parts = []

        # 1. Preamble
        latex_parts.append(self._generate_preamble())

        # 2. Title and authors
        latex_parts.append(self._generate_title(query, metadata))

        # 3. Begin document
        latex_parts.append("\\begin{document}\n\\maketitle\n")

        # 4. Abstract (extract from content)
        abstract = self._extract_abstract(content)
        if abstract:
            latex_parts.append(self._generate_abstract(abstract))

        # 5. Main content
        latex_content_body = self._convert_markdown_to_latex(content)
        latex_parts.append(latex_content_body)

        # 6. Bibliography
        # Always add bibliography commands even if no papers tracked
        # This ensures proper LaTeX compilation and makes missing references obvious
        latex_parts.append("\n\\bibliographystyle{plain}\n")
        latex_parts.append(f"\\bibliography{{{bib_basename}}}\n")

        if not referenced_papers:
            # Add comment explaining empty bibliography
            latex_parts.append("% Note: No papers were tracked during analysis\n")
            latex_parts.append("% The .bib file may be empty - check that agents called search_arxiv tools\n")

        # 7. End document
        latex_parts.append("\n\\end{document}\n")

        return "\n".join(latex_parts), bibtex_content

    def _generate_preamble(self) -> str:
        """Generate LaTeX document preamble with packages."""
        preamble = f"""% Auto-generated by Claude Research Agent
% Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

\\documentclass[{self.font_size},{self.column_mode}]{{article}}

% Standard packages
\\usepackage[utf8]{{inputenc}}
\\usepackage[T1]{{fontenc}}
\\usepackage{{lmodern}}

% Math packages
\\usepackage{{amsmath,amssymb,amsthm}}
\\usepackage{{mathtools}}

% Tables
\\usepackage{{booktabs}}
\\usepackage{{array}}
\\usepackage{{multirow}}

% Graphics and colors
\\usepackage{{xcolor}}
\\usepackage{{graphicx}}

% Algorithms
\\usepackage{{algorithm}}
\\usepackage{{algorithmic}}

% Hyperlinks (load last)
\\usepackage{{hyperref}}
\\hypersetup{{
    colorlinks=true,
    linkcolor=blue,
    citecolor=blue,
    urlcolor=blue,
}}

% Custom theorem environments
\\newtheorem{{theorem}}{{Theorem}}
\\newtheorem{{lemma}}{{Lemma}}
\\newtheorem{{definition}}{{Definition}}

% Custom colors for sections
\\definecolor{{sectioncolor}}{{RGB}}{{44,62,80}}
\\definecolor{{subsectioncolor}}{{RGB}}{{52,152,219}}

% Reduce column separation for twocolumn
\\setlength{{\\columnsep}}{{0.6cm}}

"""
        return preamble

    def _generate_title(self, query: str, metadata: Optional[Dict]) -> str:
        """Generate title, author, and metadata section."""
        # Extract short title from query
        title = f"Research Analysis: {query}"
        if len(title) > 100:
            title = title[:97] + "..."

        title_section = f"""
\\title{{{title}}}

\\author{{
    Claude Research Agent \\\\
    \\texttt{{research.agent@claude.ai}}
}}

\\date{{\\today}}
"""

        return title_section

    def _generate_abstract(self, abstract_text: str) -> str:
        """Generate abstract section."""
        # Apply inline formatting to handle bold, italic, citations, special chars
        abstract_formatted = self._convert_inline_formatting(abstract_text)

        return f"""
\\begin{{abstract}}
{abstract_formatted}
\\end{{abstract}}

"""

    def _extract_abstract(self, content: str) -> Optional[str]:
        """Extract executive summary/abstract from content."""
        lines = content.split('\n')

        # Look for Executive Summary section
        in_abstract = False
        abstract_lines = []

        for line in lines:
            if '## Executive Summary' in line or '## Abstract' in line:
                in_abstract = True
                continue
            elif in_abstract and line.startswith('##'):
                # Next section started
                break
            elif in_abstract and line.strip():
                abstract_lines.append(line.strip())

        if abstract_lines:
            return ' '.join(abstract_lines)

        return None

    def _convert_markdown_to_latex(self, content: str) -> str:
        """
        Convert markdown content to LaTeX.

        Handles:
        - Headers (##, ###)
        - Bold, italic
        - Lists
        - Tables
        - Code blocks
        - Math equations (already in LaTeX)
        - Citations [Paper N]
        """
        latex_lines = []
        lines = content.split('\n')

        i = 0
        in_code_block = False
        in_table = False
        table_lines = []

        while i < len(lines):
            line = lines[i].strip()

            # Skip title line (already in preamble)
            if line.startswith('# Research Analysis:'):
                i += 1
                continue

            # Section headers
            if line.startswith('### '):
                title = line[4:].strip()
                latex_lines.append(f"\n\\subsubsection{{{self._escape_latex(title)}}}")

            elif line.startswith('## '):
                title = line[3:].strip()
                # Skip Executive Summary (already in abstract)
                if 'Executive Summary' not in title and 'Abstract' not in title:
                    latex_lines.append(f"\n\\section{{{self._escape_latex(title)}}}")

            # Code blocks
            elif line.startswith('```'):
                if not in_code_block:
                    in_code_block = True
                    lang = line[3:].strip()
                    latex_lines.append("\n\\begin{verbatim}")
                else:
                    in_code_block = False
                    latex_lines.append("\\end{verbatim}\n")

            elif in_code_block:
                latex_lines.append(line)

            # Tables - detect by | delimiters
            elif '|' in line and not in_code_block:
                if not in_table:
                    in_table = True
                    table_lines = [line]
                else:
                    table_lines.append(line)
                    # Check if next line is still table
                    if i + 1 >= len(lines) or '|' not in lines[i + 1]:
                        # End of table, convert it
                        latex_table = self._convert_table_to_latex(table_lines)
                        latex_lines.append(latex_table)
                        in_table = False
                        table_lines = []

            # Horizontal rules
            elif line.startswith('---') or line.startswith('***'):
                latex_lines.append("\n\\noindent\\rule{\\columnwidth}{0.4pt}\n")

            # Lists
            elif line.startswith('- ') or line.startswith('* '):
                # Start itemize if needed
                if i == 0 or not (lines[i-1].startswith('- ') or lines[i-1].startswith('* ')):
                    latex_lines.append("\n\\begin{itemize}")

                item_text = line[2:].strip()
                latex_lines.append(f"  \\item {self._convert_inline_formatting(item_text)}")

                # End itemize if needed
                if i + 1 >= len(lines) or not (lines[i+1].startswith('- ') or lines[i+1].startswith('* ')):
                    latex_lines.append("\\end{itemize}\n")

            # Numbered lists
            elif re.match(r'^\d+\.', line):
                # Start enumerate if needed
                if i == 0 or not re.match(r'^\d+\.', lines[i-1]):
                    latex_lines.append("\n\\begin{enumerate}")

                item_text = re.sub(r'^\d+\.\s*', '', line)
                latex_lines.append(f"  \\item {self._convert_inline_formatting(item_text)}")

                # End enumerate if needed
                if i + 1 >= len(lines) or not re.match(r'^\d+\.', lines[i+1]):
                    latex_lines.append("\\end{enumerate}\n")

            # Math equations (display mode)
            elif line.startswith('\\['):
                latex_lines.append("\n" + line)
            elif line.startswith('\\]'):
                latex_lines.append(line + "\n")

            # Regular paragraphs
            elif line and not in_table:
                converted = self._convert_inline_formatting(line)
                latex_lines.append(converted)

            # Empty lines
            elif not in_code_block and not in_table:
                latex_lines.append("")

            i += 1

        return "\n".join(latex_lines)

    def _convert_table_to_latex(self, table_lines: List[str]) -> str:
        """Convert markdown table to LaTeX booktabs format."""
        if not table_lines:
            return ""

        # Parse table
        rows = []
        for line in table_lines:
            if '|' in line:
                # Remove outer pipes and split
                cells = [cell.strip() for cell in line.strip('|').split('|')]
                # Skip separator lines (like |---|---|)
                if not all(re.match(r'^-+$', cell.strip()) for cell in cells if cell.strip()):
                    rows.append(cells)

        if not rows:
            return ""

        # Determine number of columns
        num_cols = len(rows[0])
        col_spec = 'l' * num_cols

        # Build LaTeX table
        latex = ["\n\\begin{table}[h]"]
        latex.append("\\centering")
        latex.append(f"\\begin{{tabular}}{{{col_spec}}}")
        latex.append("\\toprule")

        # Header row
        if rows:
            header = rows[0]
            # Apply inline formatting to handle **bold**, *italic*, etc.
            header_formatted = [self._convert_inline_formatting(cell) for cell in header]
            # Wrap in \textbf only if not already formatted
            header_final = []
            for cell in header_formatted:
                if '\\textbf{' not in cell:
                    header_final.append(f"\\textbf{{{cell}}}")
                else:
                    header_final.append(cell)
            latex.append(" & ".join(header_final) + " \\\\")
            latex.append("\\midrule")

            # Data rows
            for row in rows[1:]:
                # Apply inline formatting to each cell (handles **bold**, *italic*, citations, etc.)
                row_formatted = [self._convert_inline_formatting(cell) for cell in row]
                latex.append(" & ".join(row_formatted) + " \\\\")

        latex.append("\\bottomrule")
        latex.append("\\end{tabular}")
        latex.append("\\end{table}\n")

        return "\n".join(latex)

    def _convert_inline_formatting(self, text: str) -> str:
        """Convert markdown inline formatting to LaTeX with proper escaping."""
        # Strategy: Protect special content, apply transformations, restore protected content

        protected_items = []

        def protect(match):
            """Save content and return placeholder."""
            protected_items.append(match.group(0))
            return f"<<<PROTECTED_{len(protected_items)-1}>>>"

        # 1. Protect display math environments (must come before inline math)
        text = re.sub(r'\\\[.*?\\\]', protect, text, flags=re.DOTALL)
        text = re.sub(r'\\begin\{equation\}.*?\\end\{equation\}', protect, text, flags=re.DOTALL)
        text = re.sub(r'\\begin\{align\}.*?\\end\{align\}', protect, text, flags=re.DOTALL)

        # 2. Protect inline math $...$
        text = re.sub(r'\$[^$]+?\$', protect, text)

        # 3. Protect existing LaTeX commands (including \text{...} and \cite{...})
        text = re.sub(r'\\[a-zA-Z]+(?:\{[^}]*\}|\[[^\]]*\])*', protect, text)

        # 4. Protect inline code `...` (will convert to \texttt later)
        code_blocks = []
        def protect_code(match):
            code_blocks.append(match.group(1))
            return f"<<<CODE_{len(code_blocks)-1}>>>"
        text = re.sub(r'`([^`]+?)`', protect_code, text)

        # 5. Now apply markdown conversions on remaining text
        # Bold: **text** or __text__
        text = re.sub(r'\*\*(.+?)\*\*', r'\\textbf{\1}', text)
        text = re.sub(r'__(.+?)__', r'\\textbf{\1}', text)

        # Italic: *text* or _text_ (but avoid subscripts that look like _x)
        # Only convert if surrounded by word boundaries or spaces
        text = re.sub(r'(?<!\w)\*([^*\s]+(?:\s+[^*]+?)?)\*(?!\w)', r'\\textit{\1}', text)
        text = re.sub(r'(?<!\w)_([^_\s]+(?:\s+[^_]+?)?)_(?!\w)', r'\\textit{\1}', text)

        # 6. Escape special LaTeX characters in remaining text
        # Order matters: do this AFTER markdown conversions but BEFORE restoring protected content
        special_chars = {
            '%': r'\%',
            '&': r'\&',
            '#': r'\#',
            '$': r'\$',
            '~': r'\textasciitilde{}',
            '^': r'\textasciicircum{}',
        }
        for char, replacement in special_chars.items():
            text = text.replace(char, replacement)

        # 7. Convert citations: Support both [Paper N] and [N] formats
        # Convert [Paper N] -> \cite{paperN}
        text = re.sub(r'\[Paper (\d+)\]', r'\\cite{paper\1}', text)
        # Convert [N] -> \cite{paperN} (for numeric-only citations)
        text = re.sub(r'\[(\d+)\]', r'\\cite{paper\1}', text)

        # 8. Restore code blocks as \texttt{}
        for i, code in enumerate(code_blocks):
            # Escape special chars in code
            code_escaped = code.replace('\\', '\\textbackslash{}')
            code_escaped = code_escaped.replace('{', '\\{').replace('}', '\\}')
            code_escaped = code_escaped.replace('_', '\\_')
            text = text.replace(f"<<<CODE_{i}>>>", f"\\texttt{{{code_escaped}}}")

        # 9. Restore all protected content (math, LaTeX commands)
        for i, item in enumerate(protected_items):
            text = text.replace(f"<<<PROTECTED_{i}>>>", item)

        return text

    def _escape_latex(self, text: str) -> str:
        """Escape special LaTeX characters."""
        # Don't escape if already in math mode
        if text.strip().startswith('\\') or '$' in text:
            return text

        replacements = {
            '&': '\\&',
            '%': '\\%',
            '$': '\\$',
            '#': '\\#',
            '_': '\\_',
            '{': '\\{',
            '}': '\\}',
            '~': '\\textasciitilde{}',
            '^': '\\textasciicircum{}',
        }

        for char, replacement in replacements.items():
            text = text.replace(char, replacement)

        return text

    def _generate_bibtex(self, papers: List[Dict]) -> str:
        """Generate BibTeX bibliography from ArXiv papers."""
        bibtex_entries = []

        for i, paper in enumerate(papers, 1):
            # Generate citation key
            cite_key = f"paper{i}"

            # Extract fields
            title = paper.get('title', 'Unknown Title')
            authors = paper.get('authors', [])
            year = paper.get('published', '2024')[:4] if paper.get('published') else '2024'
            arxiv_id = paper.get('arxiv_id', '')
            url = paper.get('abs_url', '')

            # Format authors
            if authors:
                if len(authors) > 5:
                    author_str = ' and '.join(authors[:5]) + ' and others'
                else:
                    author_str = ' and '.join(authors)
            else:
                author_str = 'Anonymous'

            # Create BibTeX entry
            entry = f"""@article{{{cite_key},
  title={{{title}}},
  author={{{author_str}}},
  journal={{arXiv preprint arXiv:{arxiv_id}}},
  year={{{year}}},
  url={{{url}}}
}}
"""
            bibtex_entries.append(entry)

        return "\n".join(bibtex_entries)
